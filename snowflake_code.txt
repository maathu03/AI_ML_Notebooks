CREATE OR REPLACE  TABLE DEV_BUK.DEV_SCHEMA.CONTROL_TABLE_NAME(id INT AUTOINCREMENT,table_name STRING,schema_name STRING,database_name STRING,job_frequency STRING,storage_int_name STRING,storage_loc STRING,file_type STRING,files_pattern STRING,field_delim STRING,FIELD_OPTIONALLY_ENCLOSED_BY string,file_format_name STRING,on_error STRING,skip_header INT,force BOOLEAN,size_limit INT,purge BOOLEAN,return_failed_only BOOLEAN,match_by_column_name STRING,include_metadata STRING,enforce_length BOOLEAN,truncatecolumns BOOLEAN,load_uncertain_files BOOLEAN,stage_name STRING,dw_load_timestamp timestamp default current_timestamp,is_active BOOLEAN,COMPRESSION STRING,BINARY_AS_TEXT BOOLEAN,USE_LOGICAL_TYPE BOOLEAN,TRIM_SPACE BOOLEAN,REPLACE_INVALID_CHARACTERS BOOLEAN,NULL_IF STRING,primary key(table_name, schema_name, database_name));CREATE OR REPLACE STORAGE INTEGRATION cust_sfint  TYPE = EXTERNAL_STAGE  STORAGE_PROVIDER = 'S3'  STORAGE_AWS_ROLE_ARN = 'arn:aws:iam::339712837029:role/s3sfrolenew'  ENABLED = TRUE  STORAGE_ALLOWED_LOCATIONS = ('s3://s3bucketsfnew/CSV/');  describe INTEGRATION cust_sfint;SHOW INTEGRATIONS;  create or replace TEMP table DEV_BUK.DEV_SCHEMA.log (table_name STRING, dw_load_timestamp timestamp default current_timestamp,log_details STRING);CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR)RETURNS VARCHARLANGUAGE SQLAS$$DECLARE  create_format_sql STRING ;  create_stage_sql STRING;  copy_into_sql STRING;  target_table_name STRING;  res RESULTSET DEFAULT (SELECT * FROM IDENTIFIER(:table_name)  );  c1 CURSOR FOR res;BEGIN  FOR record IN c1 DO    target_table_name := record.TABLE_NAME;      IF (record.FILE_TYPE = 'CSV') THEN        create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||                      ' TYPE = ''' || record.FILE_TYPE || ''' ' ||                     ' SKIP_HEADER = ' || record.SKIP_HEADER ||                     ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';             insert into log (table_name,dw_load_timestamp,log_details) values(:target_table_name, current_timestamp,:create_format_sql);              ELSEIF (record.FILE_TYPE = 'PARQUET') THEN        create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||                                ' TYPE = ''' || record.FILE_TYPE || ''' ' ||                                 ' COMPRESSION = ' || record.COMPRESSION ||                                 ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||                                 ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||                                 ' TRIM_SPACE = ' || record.TRIM_SPACE ||                                 ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||                                 ' NULL_IF = ' || record.NULL_IF || ';';         insert into log (table_name,dw_load_timestamp,log_details) values(:target_table_name, current_timestamp,:create_format_sql);            ELSE        RETURN 'NO SPECIFIC FILES ARE UPLOADED';    END IF;    EXECUTE IMMEDIATE create_format_sql;    create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||                             ' URL = ''' || record.STORAGE_LOC || ''' ' ||                             ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';    insert into log (table_name,dw_load_timestamp,log_details)  values(:target_table_name, current_timestamp,:create_stage_sql);     EXECUTE IMMEDIATE create_stage_sql;    copy_into_sql := 'COPY INTO '|| record.TABLE_NAME ||                          ' FROM @' || record.STAGE_NAME ||                           ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||                          ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||                          ' PURGE = ' || record.PURGE ||                          ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||                          ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||                          ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA ||                           ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||                          ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||                          ' FORCE = ' || record.FORCE ||                          ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';         insert into log (table_name,dw_load_timestamp,log_details)  values(:target_table_name, current_timestamp,:copy_into_sql);       END FOR;//  select_statement := 'SELECT * FROM log';//  result := (EXECUTE IMMEDIATE :select_statement);  RETURN copy_into_sql;END;$$;DELETE FROM log;call get_row_count('CONTROL_TABLE_NAME');select * from log;select * from customer;COPY INTO customer FROM @cust_stg_name ON_ERROR = 'SKIP_FILE' SIZE_LIMIT = 1 PURGE = true RETURN_FAILED_ONLY = true MATCH_BY_COLUMN_NAME = 'CASE_INSENSITIVE' INCLUDE_METADATA = (    ingestdate = METADATA$START_SCAN_TIME, filename = METADATA$FILENAME) ENFORCE_LENGTH = true TRUNCATECOLUMNS = FALSE FORCE = true LOAD_UNCERTAIN_FILES = true;    COPY INTO customer FROM @cust_stg_name ON_ERROR = 'SKIP_FILE'  SIZE_LIMIT = 1 PURGE = true RETURN_FAILED_ONLY = true MATCH_BY_COLUMN_NAME = 'NONE'  INCLUDE_METADATA = (    ingestdate = METADATA$START_SCAN_TIME, filename = METADATA$FILENAME) ENFORCE_LENGTH = true TRUNCATECOLUMNS = false FORCE = true LOAD_UNCERTAIN_FILES = true;    CREATE OR REPLACE FILE FORMAT cust_file_format TYPE = 'CSV'  SKIP_HEADER = 1 FIELD_OPTIONALLY_ENCLOSED_BY = '"';    CREATE OR REPLACE STAGE cust_stg_name URL = 's3://s3bucketsfnew/CSV/'  STORAGE_INTEGRATION = cust_sfint;LIST @cust_stg_name;select $1,$2,$3 from @cust_stg_name;SELECT GET_DDL('table', 'customer');select * from information_schema.columns where table_name='customer';    COPY INTO customer FROM @cust_stg_name ON_ERROR = 'SKIP_FILE'  SIZE_LIMIT = 1 PURGE = true RETURN_FAILED_ONLY = true  ENFORCE_LENGTH = true TRUNCATECOLUMNS = false FORCE = true LOAD_UNCERTAIN_FILES = true;