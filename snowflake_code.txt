CREATE OR REPLACE TABLE copy_command_audit (
    table_name STRING,
    load_date DATE,
    load_time TIMESTAMP,
    records_loaded NUMBER,
    records_rejected NUMBER,
    error_message STRING
);


CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    
    IF (record.FILE_TYPE = 'CSV') THEN
        create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                     ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                     ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                     ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
        
    ELSEIF (record.FILE_TYPE = 'PARQUET') THEN
        create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                 ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                 ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                 ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                 ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                 ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                 ' NULL_IF = ' || record.NULL_IF || ';';
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
        
    ELSE
        RETURN 'NO SPECIFIC FILES ARE UPLOADED';
    END IF;

    EXECUTE IMMEDIATE create_format_sql;

    create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                             ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                             ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
    INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_stage_sql); 
    EXECUTE IMMEDIATE create_stage_sql;

    copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                          ' FROM @' || record.STAGE_NAME ||
                          ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                          ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                          ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                          ' PURGE = ' || record.PURGE ||
                          ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                          ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                          ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                          ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                          ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                          ' FORCE = ' || record.FORCE ||
                          ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

    INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :copy_into_sql);

    BEGIN
        EXECUTE IMMEDIATE copy_into_sql;
        
        -- Initialize default values
        LET loaded_records := 0;
        LET rejected_records := 0;
        LET error_message := '';

        -- Capture the results of the COPY INTO command with exception handling
        BEGIN
            FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
                loaded_records := hist.ROWS_LOADED;
                rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
                error_message := COALESCE(hist.ERRORS, '');
            END FOR;
        EXCEPTION
            WHEN OTHERS THEN
                LET error_message := 'Error querying copy history: ' || SQLERRM;
                -- Insert the error message into the audit table
                INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
                VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
                CONTINUE;
        END;

        -- Insert the results into the audit table
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, :loaded_records, :rejected_records, :error_message);
    EXCEPTION
        WHEN OTHERS THEN
            LET error_message := 'Error executing copy command: ' || SQLERRM;
            -- Insert the error message into the audit table
            INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
            VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
    END;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;



CALL get_row_count('CONTROL_TABLE_NAME', 'daily');





########################################################
Exception / Error Handling
########################################################


CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    
    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSEIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                            ' FROM @' || record.STAGE_NAME ||
                            ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                            ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                            ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                            ' PURGE = ' || record.PURGE ||
                            ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                            ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                            ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                            ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                            ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                            ' FORCE = ' || record.FORCE ||
                            ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :copy_into_sql);
      EXECUTE IMMEDIATE copy_into_sql;

      -- Initialize default values
      LET loaded_records := 0;
      LET rejected_records := 0;
      LET error_message := '';

      -- Capture the results of the COPY INTO command with exception handling
      BEGIN
          FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
              loaded_records := hist.ROWS_LOADED;
              rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
              error_message := COALESCE(hist.ERRORS, '');
          END FOR;
      EXCEPTION
          WHEN OTHERS THEN
              error_message := 'Error querying copy history: ' || SQLERRM;
              -- Insert the error message into the audit table
              INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
              VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
              CONTINUE;
      END;

      -- Insert the results into the audit table
      INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
      VALUES (:target_table_name, CURRENT_TIMESTAMP, :loaded_records, :rejected_records, :error_message);

    EXCEPTION
      WHEN OTHERS THEN
          error_message := 'Error executing copy command: ' || SQLERRM;
          -- Insert the error message into the audit table
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
    END;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;



CALL get_row_count('YOUR_CONTROL_TABLE_NAME', 'YOUR_JOB_FREQUENCY');




=======================
Warehouse 
=======================

CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  warehouse_name STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    warehouse_name := record.WAREHOUSE;
    
    -- Set the specific warehouse for the current table
    EXECUTE IMMEDIATE 'USE WAREHOUSE ' || warehouse_name;

    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSEIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                            ' FROM @' || record.STAGE_NAME ||
                            ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                            ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                            ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                            ' PURGE = ' || record.PURGE ||
                            ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                            ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                            ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                            ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                            ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                            ' FORCE = ' || record.FORCE ||
                            ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :copy_into_sql);
      EXECUTE IMMEDIATE copy_into_sql;

      -- Initialize default values
      LET loaded_records := 0;
      LET rejected_records := 0;
      LET error_message := '';

      -- Capture the results of the COPY INTO command with exception handling
      BEGIN
          FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
              loaded_records := hist.ROWS_LOADED;
              rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
              error_message := COALESCE(hist.ERRORS, '');
          END FOR;
      EXCEPTION
          WHEN OTHERS THEN
              error_message := 'Error querying copy history: ' || SQLERRM;
              -- Insert the error message into the audit table
              INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
              VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
              CONTINUE;
      END;

      -- Insert the results into the audit table
      INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
      VALUES (:target_table_name, CURRENT_TIMESTAMP, :loaded_records, :rejected_records, :error_message);

    EXCEPTION
      WHEN OTHERS THEN
          error_message := 'Error executing copy command: ' || SQLERRM;
          -- Insert the error message into the audit table
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
    END;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;






==========================
Warehouse + Batch
==========================


CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR, batch_number VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  warehouse_name STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency AND batch_number = :batch_number
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    warehouse_name := record.WAREHOUSE;
    
    -- Set the specific warehouse for the current table
    EXECUTE IMMEDIATE 'USE WAREHOUSE ' || warehouse_name;

    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSEIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
        CONTINUE;
    END;

    BEGIN
      copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                            ' FROM @' || record.STAGE_NAME ||
                            ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                            ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                            ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                            ' PURGE = ' || record.PURGE ||
                            ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                            ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                            ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                            ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                            ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                            ' FORCE = ' || record.FORCE ||
                            ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :copy_into_sql);
      EXECUTE IMMEDIATE copy_into_sql;

      -- Initialize default values
      LET loaded_records := 0;
      LET rejected_records := 0;
      LET error_message := '';

      -- Capture the results of the COPY INTO command with exception handling
      BEGIN
          FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
              loaded_records := hist.ROWS_LOADED;
              rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
              error_message := COALESCE(hist.ERRORS, '');
          END FOR;
      EXCEPTION
          WHEN OTHERS THEN
              error_message := 'Error querying copy history: ' || SQLERRM;
              -- Insert the error message into the audit table
              INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
              VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
              CONTINUE;
      END;

      -- Insert the results into the audit table
      INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
      VALUES (:target_table_name, CURRENT_TIMESTAMP, :loaded_records, :rejected_records, :error_message);

    EXCEPTION
      WHEN OTHERS THEN
          error_message := 'Error executing copy command: ' || SQLERRM;
          -- Insert the error message into the audit table
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message);
    END;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;









==================================
Previous day execution 
==================================


CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR, batch_number VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  warehouse_name STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency AND batch_number = :batch_number
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
  last_execution_status STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    warehouse_name := record.WAREHOUSE;

    -- Check the status of the previous execution for the target table
    BEGIN
      SELECT status
      INTO last_execution_status
      FROM copy_command_audit
      WHERE table_name = :target_table_name
      ORDER BY load_time DESC
      LIMIT 1;
      
      -- If the last execution was not successful, skip the current execution
      IF last_execution_status != 'SUCCESS' THEN
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, 'Previous load failed, skipping today\'s execution');
        CONTINUE;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        -- If no previous load information is found, proceed with the execution
        last_execution_status := 'NO_DATA';
    END;

    -- Set the specific warehouse for the current table
    EXECUTE IMMEDIATE 'USE WAREHOUSE ' || warehouse_name;

    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSEIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message, 'FAILURE');
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message, 'FAILURE');
        CONTINUE;
    END;

    BEGIN
      copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                            ' FROM @' || record.STAGE_NAME ||
                            ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                            ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                            ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                            ' PURGE = ' || record.PURGE ||
                            ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                            ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                            ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                            ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                            ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                            ' FORCE = ' || record.FORCE ||
                            ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, :copy_into_sql);
      EXECUTE IMMEDIATE copy_into_sql;

      -- Initialize default values
      LET loaded_records := 0;
      LET rejected_records := 0;
      LET error_message := '';

      -- Capture the results of the COPY INTO command with exception handling
      BEGIN
          FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
              loaded_records := hist.ROWS_LOADED;
              rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
              error_message := COALESCE(hist.ERRORS, '');
          END FOR;
      EXCEPTION
          WHEN OTHERS THEN
              error_message := 'Error querying copy history: ' || SQLERRM;
              -- Insert the error message into the audit table
              INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
              VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message, 'FAILURE');
              CONTINUE;
      END;

      -- Insert the results into the audit table
      INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
      VALUES (:target_table_name, CURRENT_TIMESTAMP, :loaded_records, :rejected_records, :error_message, 'SUCCESS');

    EXCEPTION
      WHEN OTHERS THEN
          error_message := 'Error executing copy command: ' || SQLERRM;
          -- Insert the error message into the audit table
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, :error_message, 'FAILURE');
    END;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;








===========================================
1 to 1 & Transformation Load
===========================================



CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR, batch_number VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  warehouse_name STRING;
  transformation_sql STRING;
  load_type STRING; -- Add a variable for the flag
  transformation_query STRING; -- Add a variable for the transformation query
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency AND batch_number = :batch_number
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
  last_execution_status STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    warehouse_name := record.WAREHOUSE;
    load_type := record.LOAD_TYPE; -- Assuming the flag is stored in the LOAD_TYPE column
    transformation_query := record.TRANSFORMATION_QUERY; -- Assuming the transformation query is stored in the TRANSFORMATION_QUERY column

    -- Check the status of the previous execution for the target table
    BEGIN
      SELECT status
      INTO last_execution_status
      FROM copy_command_audit
      WHERE table_name = :target_table_name
      ORDER BY load_time DESC
      LIMIT 1;
      
      -- If the last execution was not successful, skip the current execution
      IF last_execution_status != 'SUCCESS' THEN
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, 'Previous load failed, skipping today''s execution');
        CONTINUE;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        -- If no previous load information is found, proceed with the execution
        last_execution_status := 'NO_DATA';
    END;

    -- Set the specific warehouse for the current table
    EXECUTE IMMEDIATE 'USE WAREHOUSE ' || warehouse_name;

    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_format_sql);
          
      ELSIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
        CONTINUE;
    END;

    -- Conditional logic based on load_type
    IF load_type = '1-to-1' THEN
      BEGIN
        copy_into_sql := 'COPY INTO ' || record.TABLE_NAME ||
                              ' FROM @' || record.STAGE_NAME ||
                              ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                              ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                              ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                              ' PURGE = ' || record.PURGE ||
                              ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                              ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                              ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                              ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                              ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                              ' FORCE = ' || record.FORCE ||
                              ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, copy_into_sql);
        EXECUTE IMMEDIATE copy_into_sql;

        -- Initialize default values
        LET loaded_records := 0;
        LET rejected_records := 0;
        LET error_message := '';

        -- Capture the results of the COPY INTO command with exception handling
        BEGIN
            FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
                loaded_records := hist.ROWS_LOADED;
                rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
                error_message := COALESCE(hist.ERRORS, '');
            END FOR;
        EXCEPTION
            WHEN OTHERS THEN
                error_message := 'Error querying copy history: ' || SQLERRM;
                -- Insert the error message into the audit table
                INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
                VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
                CONTINUE;
        END;

        -- Insert the results into the audit table
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, loaded_records, rejected_records, error_message, 'SUCCESS');

      EXCEPTION
        WHEN OTHERS THEN
            error_message := 'Error executing copy command: ' || SQLERRM;
            -- Insert the error message into the audit table
            INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
            VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
      END;

    ELSIF load_type = 'transformation' THEN
      -- Data Transformation Logic
      BEGIN
        transformation_sql := 'INSERT INTO ' || record.TRANSFORMED_TABLE_NAME || ' ' || transformation_query;
        EXECUTE IMMEDIATE transformation_sql;
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, 'Transformation executed: ' || transformation_sql);
      EXCEPTION
        WHEN OTHERS THEN
          error_message := 'Error executing transformation: ' || SQLERRM;
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, loaded_records, rejected_records, error_message, 'FAILURE');
      END;

    ELSE
      -- Handle unexpected load_type values
      RETURN 'INVALID LOAD TYPE';
    END IF;

  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;









============================================
Transform table replace
============================================


CREATE OR REPLACE PROCEDURE get_row_count(table_name VARCHAR, job_frequency VARCHAR, batch_number VARCHAR)
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  create_format_sql STRING;
  create_stage_sql STRING;
  copy_into_sql STRING;
  target_table_name STRING;
  warehouse_name STRING;
  transformation_sql STRING;
  transformation_query STRING;
  temp_table_name STRING;
  temp_transformation_query STRING;
  res RESULTSET DEFAULT (
    SELECT * 
    FROM IDENTIFIER(:table_name)
    WHERE job_frequency = :job_frequency AND batch_number = :batch_number
  );
  c1 CURSOR FOR res;
  loaded_records NUMBER DEFAULT 0;
  rejected_records NUMBER DEFAULT 0;
  error_message STRING;
  last_execution_status STRING;
BEGIN
  FOR record IN c1 DO
    target_table_name := record.TABLE_NAME;
    warehouse_name := record.WAREHOUSE;
    transformation_query := record.TRANSFORMATION_QUERY;
    temp_table_name := target_table_name || '_TEMP';

    -- Check the status of the previous execution for the target table
    BEGIN
      SELECT status
      INTO last_execution_status
      FROM copy_command_audit
      WHERE table_name = :target_table_name
      ORDER BY load_time DESC
      LIMIT 1;
      
      -- If the last execution was not successful, skip the current execution
      IF last_execution_status != 'SUCCESS' THEN
        INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, 'Previous load failed, skipping today''s execution');
        CONTINUE;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        -- If no previous load information is found, proceed with the execution
        last_execution_status := 'NO_DATA';
    END;

    -- Set the specific warehouse for the current table
    EXECUTE IMMEDIATE 'USE WAREHOUSE ' || warehouse_name;

    BEGIN
      IF (record.FILE_TYPE = 'CSV') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME || 
                       ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                       ' SKIP_HEADER = ' || record.SKIP_HEADER ||
                       ' FIELD_OPTIONALLY_ENCLOSED_BY = ''' || record.FIELD_OPTIONALLY_ENCLOSED_BY || ''';';   
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_format_sql);
          
      ELSIF (record.FILE_TYPE = 'PARQUET') THEN
          create_format_sql := 'CREATE OR REPLACE FILE FORMAT ' || record.FILE_FORMAT_NAME ||
                                  ' TYPE = ''' || record.FILE_TYPE || ''' ' ||
                                   ' COMPRESSION = ''' || record.COMPRESSION || ''' ' ||
                                   ' BINARY_AS_TEXT = ' || record.BINARY_AS_TEXT ||
                                   ' USE_LOGICAL_TYPE = ' || record.USE_LOGICAL_TYPE ||
                                   ' TRIM_SPACE = ' || record.TRIM_SPACE ||
                                   ' REPLACE_INVALID_CHARACTERS = ' || record.REPLACE_INVALID_CHARACTERS ||
                                   ' NULL_IF = ' || record.NULL_IF || ';';
          INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_format_sql);
          
      ELSE
          RETURN 'NO SPECIFIC FILES ARE UPLOADED';
      END IF;

      EXECUTE IMMEDIATE create_format_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating file format: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
        CONTINUE;
    END;

    BEGIN
      create_stage_sql := 'CREATE OR REPLACE STAGE ' || record.STAGE_NAME ||
                               ' URL = ''' || record.STORAGE_LOC || ''' ' ||
                               ' STORAGE_INTEGRATION = ' || record.STORAGE_INT_NAME || ';';
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, create_stage_sql); 
      EXECUTE IMMEDIATE create_stage_sql;

    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error creating stage: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
        CONTINUE;
    END;

    BEGIN
      -- Create the temporary table
      EXECUTE IMMEDIATE 'CREATE OR REPLACE TEMP TABLE ' || temp_table_name || ' LIKE ' || target_table_name;

      copy_into_sql := 'COPY INTO ' || temp_table_name ||
                        ' FROM @' || record.STAGE_NAME ||
                        ' FILE_FORMAT = (FORMAT_NAME = ' || record.FILE_FORMAT_NAME || ') ' ||
                        ' ON_ERROR = ''' || record.ON_ERROR || ''' ' ||
                        ' SIZE_LIMIT = ' || record.SIZE_LIMIT ||
                        ' PURGE = ' || record.PURGE ||
                        ' RETURN_FAILED_ONLY = ' || record.RETURN_FAILED_ONLY ||
                        ' MATCH_BY_COLUMN_NAME = ''' || record.MATCH_BY_COLUMN_NAME || ''' ' ||
                        ' INCLUDE_METADATA = ' || record.INCLUDE_METADATA || 
                        ' ENFORCE_LENGTH = ' || record.ENFORCE_LENGTH ||
                        ' TRUNCATECOLUMNS = ' || record.TRUNCATECOLUMNS ||
                        ' FORCE = ' || record.FORCE ||
                        ' LOAD_UNCERTAIN_FILES = ' || record.LOAD_UNCERTAIN_FILES || ';';

      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, copy_into_sql);
      EXECUTE IMMEDIATE copy_into_sql;

      -- Initialize default values
      LET loaded_records := 0;
      LET rejected_records := 0;
      LET error_message := '';

      -- Capture the results of the COPY INTO command with exception handling
      BEGIN
          FOR hist IN (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))) DO
              loaded_records := hist.ROWS_LOADED;
              rejected_records := hist.ROWS_PARSED - hist.ROWS_LOADED;
              error_message := COALESCE(hist.ERRORS, '');
          END FOR;
      EXCEPTION
          WHEN OTHERS THEN
              error_message := 'Error querying copy history: ' || SQLERRM;
              -- Insert the error message into the audit table
              INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
              VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
              CONTINUE;
      END;

      -- Insert the results into the audit table
      INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
      VALUES (:target_table_name, CURRENT_TIMESTAMP, loaded_records, rejected_records, error_message, 'SUCCESS');

    EXCEPTION
      WHEN OTHERS THEN
          error_message := 'Error executing copy command: ' || SQLERRM;
          -- Insert the error message into the audit table
          INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
          VALUES (:target_table_name, CURRENT_TIMESTAMP, 0, 0, error_message, 'FAILURE');
    END;

    -- Data Transformation Logic
    -- Dynamically replace original table names with temporary table names in the transformation query
    BEGIN
      FOR row IN (SELECT table_name FROM information_schema.tables WHERE table_schema = 'YOUR_SCHEMA_NAME') DO
        temp_transformation_query := REPLACE(transformation_query, row.table_name, row.table_name || '_TEMP');
        transformation_query := temp_transformation_query; -- Update the transformation_query with the new value
      END FOR;

      transformation_sql := 'INSERT INTO ' || record.TRANSFORMED_TABLE_NAME || ' ' || temp_transformation_query;
      EXECUTE IMMEDIATE transformation_sql;
      INSERT INTO log (table_name, dw_load_timestamp, log_details) VALUES (:target_table_name, CURRENT_TIMESTAMP, 'Transformation executed: ' || transformation_sql);
    EXCEPTION
      WHEN OTHERS THEN
        error_message := 'Error executing transformation: ' || SQLERRM;
        INSERT INTO copy_command_audit (table_name, load_time, records_loaded, records_rejected, error_message, status)
        VALUES (:target_table_name, CURRENT_TIMESTAMP, loaded_records, rejected_records, error_message, 'FAILURE');
    END;

  END FOR;

  -- Drop temporary tables
  FOR temp_table IN (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME LIKE '%_TEMP' AND TABLE_SCHEMA = 'YOUR_SCHEMA_NAME') DO
    EXECUTE IMMEDIATE 'DROP TABLE ' || temp_table.TABLE_NAME;
  END FOR;

  RETURN 'Data load commands executed successfully';
END;
$$;

